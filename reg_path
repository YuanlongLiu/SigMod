	library(igraph)
	##this function generates all different selections 
	##last modified: 03-11-2015
	##connectivity: lambda; interconnectivity: gama; sparsity: eta
	##compute linear k(\lambda) for each cut

	##this function calculates the capacity line
	capac_info <- function(net, lambda, gama, eta)
	{
		st_info = st_sans_seed(net, lambda, gama, eta) 
		change_points = st_info$change_points
		
		cut_info = st_info$st_cut
		st_net = st_info$st_net
		selected = st_info$selected

		slope = length( selected )
		##adjust the capacity curve so that it's convex
		{
			d_s = degree( st_net, v='s' ) ##number of nodes connected with 's'
			delta = -sum( rep(eta, d_s) - change_points[1:d_s] )
			cut_val = cut_info$value - delta
		}

		intercept = cut_val - slope*eta
		capac_line = list(ax=slope, b=intercept)
		return( list(capac_line=capac_line, selected=selected) ) ##ax + b
	}	

	##the regularization path
	reg_path <- function( net, lambda, gama, eta_max, eta_min, capac_infos, selection_diff=1, selection_min=70 )
	{	
		selected = list()
		selected[[1]] = capac_infos[[1]]$selected
		selected[[2]] = capac_infos[[2]]$selected
		
		##stop if the difference between selection is smaller than selection_diff
		if( abs( length(selected[[1]]) - length(selected[[2]]) ) <= selection_diff ) return( list( selected[[1]], selected[[2]] ) )
		if( max( length(selected[[1]]) , length(selected[[2]]) ) <= selection_min ) return( list( selected[[1]], selected[[2]] ) )

		##divide and conquer
		cat('search in subinterval::', sample(1:100,1), '\n')
		etas = c( eta_max, eta_min )
		
		cut_lines = list()
		cut_lines[[1]] = capac_infos[[1]]$capac_line
		cut_lines[[2]] = capac_infos[[2]]$capac_line
		
		##else sparsity_mid equals the intersection of two cut_val lines
		eta_mid = ( cut_lines[[2]]$b - cut_lines[[1]]$b ) / ( -cut_lines[[2]]$ax + cut_lines[[1]]$ax )
		##no more selections between
		criterion_b = any( abs(c(eta_mid - etas[1], eta_mid - etas[2])) < 1E-7 )
		if( criterion_b )
		{ #cat(min(abs(c(eta_mid - etas[1], eta_mid - etas[2]))), '\n'); 
		return( list( selected[[1]], selected[[2]] ) ) }
		
		##error if the intersection is outside
		non_concave = ( eta_mid > max( etas[1], etas[2] ) ) | ( eta_mid < min( etas[1], etas[2] ) )
		if( is.na(non_concave) ) { cat('Incorrect slope of capac_line\n'); return(-1) }
		# if( non_concave ) {cat('capac_line neither concave nor convex\n'); return(-1)}
		if( non_concave ) {cat(eta_min, eta_mid, eta_max); return(-1)}
		

		
		capac_info_mid = capac_info( net, lambda, gama, eta=eta_mid )
		
		net_head = induced.subgraph( net, capac_info_mid$selected )
		reg_paths_head  = reg_path( net_head, lambda, gama, etas[1], eta_mid, list(capac_infos[[1]], capac_info_mid), selection_diff )
		reg_paths_tail  = reg_path( net, lambda, gama, eta_mid, etas[2], list(capac_info_mid, capac_infos[[2]]), selection_diff )
	
		return( c( reg_paths_head, reg_paths_tail ) ) 
	}

	selection_path <- function( net, lambda, gama, eta_max=1E7, eta_min, selection_diff=1, selection_min=70 )
	{
		capac_infos = list()
		capac_infos[[1]] = capac_info(net=net, lambda, gama, eta=eta_max )
		capac_infos[[2]] = capac_info(net=net, lambda, gama, eta=eta_min )
		cat('selected max::', length(capac_infos[[2]]$selected), ' | ', '\n')
		result = reg_path( net, lambda, gama, eta_max, eta_min, capac_infos, selection_diff, selection_min )
		result = result[!duplicated(sapply(result,length))]
		return( result[ order(sapply( result, length )) ] )
	}
	
